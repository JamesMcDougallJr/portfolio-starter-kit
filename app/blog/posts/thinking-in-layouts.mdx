---
title: 'Thinking in Layouts'
publishedAt: '2024-04-08'
summary: 'When designing user interfaces, developers often have to think from from bits to bytes to React components. But this immense amount of complexity doesn't stop with components. Thinking in layouts proposes adding one more high level concept to make building awesome websites even more fun.'
---

## The Component Trap

As frontend developers, we've all been there. A new project starts, and immediately we begin breaking down the UI into components. A button here, an input field there, maybe a card component for good measure. We pride ourselves on creating reusable, modular code that can be shared across applications, verticals, or even companies.

But here's the uncomfortable truth: **how often do those "reusable" components actually get reused?**

More often than not, components get created, used once, thoroughly tested, documented, and then... forgotten. They sit in your component library collecting digital dust while new teams create slightly different versions of the same thing because the original "didn't quite fit" their use case.

This is the component trap, and nearly every frontend developer has fallen into it.

## Think Bigger: The Layout Mindset

The solution isn't to build more generic components or to create even more abstraction layers. Instead, we need to **think one level higher**. We need to think in terms of **layouts**.

### What Are Layouts?

Layouts are compositional patterns that define how components work together to solve common user interface problems. They can be an entire page, a section of a page, or a reusable pattern that appears across your application. Layouts are composed of components, but they represent the *structure* and *relationships* between those components.

Think of it this way:
- **Components** are the building blocks (buttons, inputs, cards)
- **Layouts** are the blueprints (how those blocks fit together)

When you think in layouts, you're solving problems at the right level of abstraction.

## Real-World Example: The Dashboard Problem

Let's consider a practical scenario. You're building a SaaS platform with multiple product verticals - maybe you have an analytics dashboard, a user management interface, and a reporting system.

### The Component-First Approach (What Most Teams Do)

Your team might create:
- A custom `AnalyticsButton` with specific styling
- A custom `UserManagementButton` with different colors
- A custom `ReportButton` with unique icons
- Three different table components, each slightly different
- Multiple navigation patterns that don't quite match

Six months later, you have hundreds of components, tons of code duplication, and no clear path forward.

### The Layout-First Approach (The Better Way)

Instead, consider the common patterns:

```jsx
// A flexible DashboardLayout that works everywhere
function DashboardLayout({
  title,
  actions,
  sidebar,
  children
}) {
  return (
    <div className="dashboard-container">
      <header>
        <h1>{title}</h1>
        <div className="actions">{actions}</div>
      </header>
      <div className="content-wrapper">
        {sidebar && <aside>{sidebar}</aside>}
        <main>{children}</main>
      </div>
    </div>
  )
}

// Now ANY vertical can use this
function AnalyticsDashboard() {
  return (
    <DashboardLayout
      title="Analytics"
      actions={<CustomAnalyticsButton />}
      sidebar={<AnalyticsFilters />}
    >
      <DataTable data={analyticsData} />
    </DashboardLayout>
  )
}

function UserManagementDashboard() {
  return (
    <DashboardLayout
      title="Users"
      actions={<CustomUserButton />}
      sidebar={<UserFilters />}
    >
      <DataTable data={userData} />
    </DashboardLayout>
  )
}
```

Notice what happened here:
1. **Solve the hard problem once**: The responsive layout, header positioning, sidebar behavior - these are complex and should be solved once
2. **Allow customization where it matters**: Each vertical gets their custom button and filters
3. **Reuse the actual complex code**: The `DataTable` is shared because tables are genuinely hard to build right

## The 80/20 Rule of UI Development

Here's a principle I've discovered through years of building web applications:

**80% of your UI complexity lives in layouts and data patterns. Only 20% is in the individual components.**

Think about what's actually hard:
- ✅ Responsive layouts that work on mobile, tablet, and desktop
- ✅ Data tables with sorting, filtering, pagination, and virtualization
- ✅ Forms with validation, error handling, and submission states
- ✅ Authentication flows and protected routes
- ✅ Navigation patterns and deep linking
- ✅ Loading states and error boundaries

Compare that to what's easy:
- ❌ A button (seriously, it's just a button)
- ❌ An icon (it's an SVG)
- ❌ A badge or label
- ❌ A custom text style

Yet teams often spend equal time on both categories, creating elaborate component libraries for simple elements while every vertical re-implements their own data table.

## Practical Patterns: Common Layouts

Here are some layout patterns that apply across nearly every web application:

### 1. The Dashboard Layout

```jsx
<DashboardLayout
  header={<Header />}
  sidebar={<Navigation />}
  content={<MainContent />}
/>
```

Handles: Responsive sidebar collapse, header sticky behavior, scroll management.

### 2. The List-Detail Layout

```jsx
<ListDetailLayout
  list={<ItemList />}
  detail={<ItemDetail />}
  splitRatio={0.3}
/>
```

Handles: Split view on desktop, stacked on mobile, selection state, deep linking.

### 3. The Form Layout

```jsx
<FormLayout
  sections={[
    { title: "Personal Info", fields: [...] },
    { title: "Settings", fields: [...] }
  ]}
  onSubmit={handleSubmit}
/>
```

Handles: Multi-step forms, validation, error display, submission states, accessibility.

### 4. The Data Display Layout

```jsx
<DataDisplayLayout
  filters={<Filters />}
  table={<DataTable />}
  pagination={<Pagination />}
  actions={<BulkActions />}
/>
```

Handles: Filter positioning, bulk actions, loading states, empty states, responsive behavior.

## Implementation Strategy

So how do you actually adopt this mindset? Here's a practical approach:

### 1. Audit Your Existing Patterns

Look at your application and identify repeating structural patterns. Don't look at the components themselves - look at how they're arranged. You'll likely find 5-10 core layouts that cover 90% of your UI.

### 2. Extract Layout Components

Create layout components that handle:
- Positioning and spacing
- Responsive behavior
- Common states (loading, error, empty)
- Accessibility concerns

### 3. Make Them Composable

Use composition patterns like slots, render props, or children:

```jsx
<ContentLayout>
  <ContentLayout.Header>
    <h1>Title</h1>
  </ContentLayout.Header>
  <ContentLayout.Sidebar>
    <Navigation />
  </ContentLayout.Sidebar>
  <ContentLayout.Main>
    <YourContent />
  </ContentLayout.Main>
</ContentLayout>
```

### 4. Let Teams Customize Details

The layout handles structure. Teams bring their own:
- Specific buttons and controls
- Custom styling and theming
- Domain-specific logic
- Unique content

## The Benefits You'll See

When you adopt layout-first thinking, you'll notice:

### 1. Genuine Code Reuse
Your core layouts get used across every feature and vertical because they solve real, complex problems.

### 2. Faster Development
New features use existing layouts. Teams spend time on business logic, not wrestling with CSS Grid for the hundredth time.

### 3. Consistent UX
When layouts are shared, your application naturally has consistent patterns. Users don't have to relearn navigation in each section.

### 4. Easier Maintenance
Need to update how your app handles mobile navigation? Change it in one layout component, not scattered across 50 files.

### 5. Better Performance
Complex responsive logic and calculations happen once in the layout, not repeated in every component.

## Common Mistakes to Avoid

### Mistake #1: Making Layouts Too Rigid

Don't create layouts that enforce every detail. Allow teams to customize:

```jsx
// ❌ Too rigid
<DashboardLayout
  buttonColor="blue"
  buttonSize="large"
/>

// ✅ Flexible
<DashboardLayout
  actions={<YourCustomButton />}
/>
```

### Mistake #2: Thinking Everything is a Layout

Not every repeated pattern needs to be a layout. Simple, truly generic components (like actual buttons) can stay as components.

### Mistake #3: Over-Abstracting

Start with concrete layouts that solve real problems. Don't try to build "the one layout to rule them all."

## Conclusion: Change How You Think

The shift from component-first to layout-first thinking is subtle but powerful. It's not about abandoning components - it's about understanding that **components are your materials, but layouts are your architecture**.

When you start seeing your application as a collection of layout patterns rather than a pile of components, something clicks. You stop fighting the same battles repeatedly. You stop creating components that never get reused. You start building systems that actually scale.

Next time you start a new feature or project, ask yourself: "What's the layout pattern here?" before you ask "What components do I need?"

Your future self (and your teammates) will thank you.

---

## Key Takeaways

- Most "reusable" components never get reused because they solve small, easy problems
- **Layouts solve the actually hard problems**: responsive behavior, complex state management, interaction patterns
- Think 80/20: 80% of complexity is in layouts, 20% in components
- Extract common layout patterns and let teams customize the details
- Focus your engineering effort on solving hard problems once, not easy problems many times

